"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateParser = void 0;
const langium_1 = require("langium");
const package_1 = require("./package");
async function validateParser(grammar, config, grammarConfigMap, grammarServices) {
    var _a;
    const parserConfig = Object.assign(Object.assign(Object.assign({}, config.chevrotainParserConfig), (_a = grammarConfigMap.get(grammar)) === null || _a === void 0 ? void 0 : _a.chevrotainParserConfig), { skipValidations: false });
    const services = await (0, langium_1.createServicesForGrammar)({
        grammarServices,
        grammar,
        languageMetaData: languageConfigToMetaData(grammarConfigMap.get(grammar)),
        parserConfig
    });
    let parser;
    try {
        parser = (0, langium_1.prepareLangiumParser)(services);
        // The finalization step invokes parser validation, which can lead to thrown errors
        parser.finalize();
        return undefined;
    }
    catch (err) {
        if (parser && parser.definitionErrors.length > 0) {
            // Construct a message with tracing information
            let message = 'Parser definition errors detected:';
            for (const defError of parser.definitionErrors) {
                message += '\n-------------------------------\n';
                if (defError.ruleName) {
                    const rule = findRule(defError.ruleName, grammar, grammarServices.shared.workspace.LangiumDocuments);
                    if (rule && rule.$cstNode) {
                        const filePath = (0, package_1.getFilePath)((0, langium_1.getDocument)(rule).uri.fsPath, config);
                        const line = rule.$cstNode.range.start.line + 1;
                        message += `${filePath}:${line} - `;
                    }
                }
                message += defError.message;
            }
            return new Error(message);
        }
        if (err instanceof Error) {
            return err;
        }
        throw err;
    }
}
exports.validateParser = validateParser;
function languageConfigToMetaData(config) {
    var _a;
    return {
        languageId: config.id,
        fileExtensions: (_a = config.fileExtensions) !== null && _a !== void 0 ? _a : [],
        caseInsensitive: Boolean(config.caseInsensitive)
    };
}
function findRule(name, grammar, documents) {
    for (const rule of grammar.rules) {
        if (rule.name === name && langium_1.GrammarAST.isParserRule(rule)) {
            return rule;
        }
    }
    for (const document of documents.all) {
        const ast = document.parseResult.value;
        if (langium_1.GrammarAST.isGrammar(ast)) {
            for (const rule of ast.rules) {
                if (rule.name === name && langium_1.GrammarAST.isParserRule(rule)) {
                    return rule;
                }
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=parser-validation.js.map