"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = require("commander");
const jsonschema_1 = require("jsonschema");
const generate_1 = require("./generate");
const util_1 = require("./generator/util");
const package_1 = require("./package");
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const program = new commander_1.Command();
program
    .version(util_1.cliVersion)
    .command('generate')
    .description('Generate code for a Langium grammar')
    .option('-f, --file <file>', 'the configuration file or package.json setting up the generator')
    .option('-w, --watch', 'enables watch mode', false)
    .action((options) => {
    forEachConfig(options, generate_1.generate).catch(err => {
        console.error(err);
        process.exit(1);
    });
});
program.command('extract-types')
    .argument('<file>', 'the langium grammar file to generate types for')
    .option('-o, --output <file>', 'output file name. Default is types.langium next to the grammar file.')
    .option('-f, --force', 'Force overwrite existing file.')
    .action((file, options) => {
    options.grammar = file;
    (0, generate_1.generateTypes)(options).catch(err => {
        console.error(err);
        process.exit(1);
    });
})
    .action;
program.parse(process.argv);
async function forEachConfig(options, callback) {
    const configs = await (0, package_1.loadConfigs)(options);
    const validation = (0, jsonschema_1.validate)(configs, util_1.schema, {
        nestedErrors: true
    });
    if (!validation.valid) {
        (0, util_1.log)('error', options, chalk_1.default.red('Error: Your Langium configuration is invalid.'));
        const errors = validation.errors.filter(error => error.path.length > 0);
        errors.forEach(error => {
            (0, util_1.log)('error', options, `--> ${error.stack}`);
        });
        process.exit(1);
    }
    const results = await Promise.all(configs.map(config => {
        config.projectName = lodash_1.default.camelCase(config.projectName);
        config.projectName = config.projectName.charAt(0).toUpperCase() + config.projectName.slice(1);
        return callback(config, options);
    }));
    const allSuccessful = results.every(result => result === 'success');
    if (options.watch) {
        if (allSuccessful) {
            console.log(`${(0, util_1.getTime)()}Langium generator finished ${chalk_1.default.green.bold('successfully')} in ${(0, util_1.elapsedTime)()}ms`);
        }
        console.log((0, util_1.getTime)() + 'Langium generator will continue running in watch mode');
        for (const config of configs) {
            for (const language of config.languages) {
                const grammarPath = path_1.default.resolve(config[package_1.RelativePath], language.grammar);
                fs_extra_1.default.watchFile(grammarPath, async () => {
                    console.log((0, util_1.getTime)() + 'File change detected. Starting compilation...');
                    (0, util_1.elapsedTime)();
                    if (await callback(config, options) === 'success') {
                        console.log(`${(0, util_1.getTime)()}Langium generator finished ${chalk_1.default.green.bold('successfully')} in ${(0, util_1.elapsedTime)()}ms`);
                    }
                });
            }
        }
    }
    else if (!allSuccessful) {
        process.exit(1);
    }
    else {
        console.log(`Langium generator finished ${chalk_1.default.green.bold('successfully')} in ${(0, util_1.elapsedTime)()}ms`);
    }
}
//# sourceMappingURL=langium.js.map