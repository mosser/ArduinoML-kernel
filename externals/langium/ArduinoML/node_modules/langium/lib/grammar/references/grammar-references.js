"use strict";
/******************************************************************************
* Copyright 2021 TypeFox GmbH
* This program and the accompanying materials are made available under the
* terms of the MIT License, which is available in the project root.
******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarReferences = void 0;
const references_1 = require("../../references/references");
const ast_util_1 = require("../../utils/ast-util");
const cst_util_1 = require("../../utils/cst-util");
const grammar_util_1 = require("../../utils/grammar-util");
const stream_1 = require("../../utils/stream");
const uri_util_1 = require("../../utils/uri-util");
const ast_1 = require("../generated/ast");
const internal_grammar_util_1 = require("../internal-grammar-util");
const types_util_1 = require("../type-system/types-util");
class LangiumGrammarReferences extends references_1.DefaultReferences {
    constructor(services) {
        super(services);
        this.documents = services.shared.workspace.LangiumDocuments;
    }
    findDeclaration(sourceCstNode) {
        const nodeElem = sourceCstNode.element;
        const assignment = (0, grammar_util_1.findAssignment)(sourceCstNode);
        if (assignment && assignment.feature === 'feature') {
            // Only search for a special declaration if the cst node is the feature property of the action/assignment
            if ((0, ast_1.isAssignment)(nodeElem)) {
                return this.findAssignmentDeclaration(nodeElem);
            }
            else if ((0, ast_1.isAction)(nodeElem)) {
                return this.findActionDeclaration(nodeElem);
            }
        }
        return super.findDeclaration(sourceCstNode);
    }
    findLocalReferences(targetNode, includeDeclaration = false) {
        if ((0, ast_1.isTypeAttribute)(targetNode)) {
            const doc = (0, ast_util_1.getDocument)(targetNode);
            const rootNode = doc.parseResult.value;
            return this.findLocalReferencesToTypeAttribute(targetNode, rootNode, includeDeclaration);
        }
        else {
            return super.findLocalReferences(targetNode, includeDeclaration);
        }
    }
    findGlobalReferences(targetNode, includeDeclaration = false) {
        if ((0, ast_1.isTypeAttribute)(targetNode)) {
            return this.findReferencesToTypeAttribute(targetNode, includeDeclaration);
        }
        else {
            return super.findGlobalReferences(targetNode, includeDeclaration);
        }
    }
    findLocalReferencesToTypeAttribute(targetNode, rootNode, includeDeclaration) {
        const refs = [];
        const interfaceNode = (0, ast_util_1.getContainerOfType)(targetNode, ast_1.isInterface);
        if (interfaceNode) {
            const interfaces = (0, types_util_1.collectChildrenTypes)(interfaceNode, this, this.documents, this.nodeLocator);
            const targetRules = [];
            interfaces.forEach(interf => {
                const rules = this.findLocalRulesWithReturnType(interf, rootNode);
                targetRules.push(...rules);
            });
            if ((0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(targetNode).uri, (0, ast_util_1.getDocument)(rootNode).uri) && includeDeclaration) {
                const ref = this.getReferenceToSelf(targetNode);
                if (ref) {
                    refs.push(ref);
                }
            }
            targetRules.forEach(rule => {
                const references = this.createReferencesToAttribute(rule, targetNode);
                refs.push(...references);
            });
        }
        return (0, stream_1.stream)(refs);
    }
    findReferencesToTypeAttribute(targetNode, includeDeclaration) {
        const refs = [];
        const interfaceNode = (0, ast_util_1.getContainerOfType)(targetNode, ast_1.isInterface);
        if (interfaceNode) {
            if (includeDeclaration) {
                const ref = this.getReferenceToSelf(targetNode);
                if (ref) {
                    refs.push(ref);
                }
            }
            const interfaces = (0, types_util_1.collectChildrenTypes)(interfaceNode, this, this.documents, this.nodeLocator);
            const targetRules = [];
            interfaces.forEach(interf => {
                const rules = this.findRulesWithReturnType(interf);
                targetRules.push(...rules);
            });
            targetRules.forEach(rule => {
                const references = this.createReferencesToAttribute(rule, targetNode);
                refs.push(...references);
            });
        }
        return (0, stream_1.stream)(refs);
    }
    createReferencesToAttribute(ruleOrAction, attribute) {
        const refs = [];
        if ((0, ast_1.isParserRule)(ruleOrAction)) {
            const assignment = (0, internal_grammar_util_1.extractAssignments)(ruleOrAction.definition).find(a => a.feature === attribute.name);
            if (assignment === null || assignment === void 0 ? void 0 : assignment.$cstNode) {
                const leaf = this.nameProvider.getNameNode(assignment);
                if (leaf) {
                    refs.push({
                        sourceUri: (0, ast_util_1.getDocument)(assignment).uri,
                        sourcePath: this.nodeLocator.getAstNodePath(assignment),
                        targetUri: (0, ast_util_1.getDocument)(attribute).uri,
                        targetPath: this.nodeLocator.getAstNodePath(attribute),
                        segment: (0, cst_util_1.toDocumentSegment)(leaf),
                        local: (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(assignment).uri, (0, ast_util_1.getDocument)(attribute).uri)
                    });
                }
            }
        }
        else {
            // If the action references the attribute directly
            if (ruleOrAction.feature === attribute.name) {
                const leaf = (0, grammar_util_1.findNodeForProperty)(ruleOrAction.$cstNode, 'feature');
                if (leaf) {
                    refs.push({
                        sourceUri: (0, ast_util_1.getDocument)(ruleOrAction).uri,
                        sourcePath: this.nodeLocator.getAstNodePath(ruleOrAction),
                        targetUri: (0, ast_util_1.getDocument)(attribute).uri,
                        targetPath: this.nodeLocator.getAstNodePath(attribute),
                        segment: (0, cst_util_1.toDocumentSegment)(leaf),
                        local: (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(ruleOrAction).uri, (0, ast_util_1.getDocument)(attribute).uri)
                    });
                }
            }
            // Find all references within the parser rule that contains this action
            const parserRule = (0, ast_util_1.getContainerOfType)(ruleOrAction, ast_1.isParserRule);
            refs.push(...this.createReferencesToAttribute(parserRule, attribute));
        }
        return refs;
    }
    findAssignmentDeclaration(assignment) {
        var _a;
        const parserRule = (0, ast_util_1.getContainerOfType)(assignment, ast_1.isParserRule);
        const action = (0, internal_grammar_util_1.getActionAtElement)(assignment);
        if (action) {
            const actionDeclaration = this.findActionDeclaration(action, assignment.feature);
            if (actionDeclaration) {
                return actionDeclaration;
            }
        }
        if ((_a = parserRule === null || parserRule === void 0 ? void 0 : parserRule.returnType) === null || _a === void 0 ? void 0 : _a.ref) {
            if ((0, ast_1.isInterface)(parserRule.returnType.ref) || (0, ast_1.isType)(parserRule.returnType.ref)) {
                const interfaces = (0, types_util_1.collectSuperTypes)(parserRule.returnType.ref);
                for (const interf of interfaces) {
                    const typeAttribute = interf.attributes.find(att => att.name === assignment.feature);
                    if (typeAttribute) {
                        return typeAttribute;
                    }
                }
            }
        }
        return assignment;
    }
    findActionDeclaration(action, featureName) {
        var _a;
        if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {
            const feature = featureName !== null && featureName !== void 0 ? featureName : action.feature;
            const interfaces = (0, types_util_1.collectSuperTypes)(action.type.ref);
            for (const interf of interfaces) {
                const typeAttribute = interf.attributes.find(att => att.name === feature);
                if (typeAttribute) {
                    return typeAttribute;
                }
            }
        }
        return undefined;
    }
    findRulesWithReturnType(interf) {
        const rules = [];
        const refs = this.index.findAllReferences(interf, this.nodeLocator.getAstNodePath(interf));
        refs.forEach(ref => {
            const doc = this.documents.getOrCreateDocument(ref.sourceUri);
            const astNode = this.nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);
            if ((0, ast_1.isParserRule)(astNode) || (0, ast_1.isAction)(astNode)) {
                rules.push(astNode);
            }
        });
        return rules;
    }
    findLocalRulesWithReturnType(interf, rootNode) {
        const rules = [];
        const parserRulesOrActions = (0, ast_util_1.streamAst)(rootNode).filter(node => { var _a, _b; return ((0, ast_1.isParserRule)(node) && ((_a = node.returnType) === null || _a === void 0 ? void 0 : _a.ref) === interf) || ((0, ast_1.isAction)(node) && ((_b = node.type) === null || _b === void 0 ? void 0 : _b.ref) === interf); });
        parserRulesOrActions.forEach(rule => {
            if ((0, ast_1.isParserRule)(rule) || (0, ast_1.isAction)(rule)) {
                rules.push(rule);
            }
        });
        return rules;
    }
}
exports.LangiumGrammarReferences = LangiumGrammarReferences;
//# sourceMappingURL=grammar-references.js.map