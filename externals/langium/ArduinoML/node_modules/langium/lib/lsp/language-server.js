"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRequestHandler = exports.createServerRequestHandler = exports.createCallHierarchyRequestHandler = exports.addCallHierarchyHandler = exports.addCodeLensHandler = exports.addSignatureHelpHandler = exports.addDocumentLinkHandler = exports.addExecuteCommandHandler = exports.addConfigurationChangeHandler = exports.addSemanticTokenHandler = exports.addRenameHandler = exports.addFormattingHandler = exports.addFoldingRangeHandler = exports.addHoverHandler = exports.addDocumentHighlightsHandler = exports.addGoToDeclarationHandler = exports.addGoToImplementationHandler = exports.addGoToTypeDefinitionHandler = exports.addGotoDefinitionHandler = exports.addDocumentSymbolHandler = exports.addCodeActionHandler = exports.addFindReferencesHandler = exports.addCompletionHandler = exports.addDiagnosticsHandler = exports.addDocumentsHandler = exports.startLanguageServer = exports.DefaultLanguageServer = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const dependency_injection_1 = require("../dependency-injection");
const promise_util_1 = require("../utils/promise-util");
const documents_1 = require("../workspace/documents");
const semantic_token_provider_1 = require("./semantic-token-provider");
const signature_help_provider_1 = require("./signature-help-provider");
class DefaultLanguageServer {
    constructor(services) {
        this.onInitializeEmitter = new vscode_languageserver_1.Emitter();
        this.onInitializedEmitter = new vscode_languageserver_1.Emitter();
        this.services = services;
    }
    get onInitialize() {
        return this.onInitializeEmitter.event;
    }
    get onInitialized() {
        return this.onInitializedEmitter.event;
    }
    async initialize(params) {
        this.eagerLoadServices();
        this.onInitializeEmitter.fire(params);
        this.onInitializeEmitter.dispose();
        return this.buildInitializeResult(params);
    }
    /**
     * Eagerly loads all services before emitting the `onInitialize` event.
     * Ensures that all services are able to catch the event.
     */
    eagerLoadServices() {
        (0, dependency_injection_1.eagerLoad)(this.services);
        this.services.ServiceRegistry.all.forEach(language => (0, dependency_injection_1.eagerLoad)(language));
    }
    hasService(callback) {
        return this.services.ServiceRegistry.all.some(language => callback(language) !== undefined);
    }
    buildInitializeResult(_params) {
        var _a;
        const languages = this.services.ServiceRegistry.all;
        const hasFormattingService = this.hasService(e => e.lsp.Formatter);
        const formattingOnTypeOptions = languages.map(e => { var _a; return (_a = e.lsp.Formatter) === null || _a === void 0 ? void 0 : _a.formatOnTypeOptions; }).find(e => Boolean(e));
        const hasCodeActionProvider = this.hasService(e => e.lsp.CodeActionProvider);
        const hasSemanticTokensProvider = this.hasService(e => e.lsp.SemanticTokenProvider);
        const commandNames = (_a = this.services.lsp.ExecuteCommandHandler) === null || _a === void 0 ? void 0 : _a.commands;
        const documentLinkProvider = this.services.lsp.DocumentLinkProvider;
        const signatureHelpOptions = (0, signature_help_provider_1.mergeSignatureHelpOptions)(languages.map(e => { var _a; return (_a = e.lsp.SignatureHelp) === null || _a === void 0 ? void 0 : _a.signatureHelpOptions; }));
        const hasGoToTypeProvider = this.hasService(e => e.lsp.TypeProvider);
        const hasGoToImplementationProvider = this.hasService(e => e.lsp.ImplementationProvider);
        const hasCompletionProvider = this.hasService(e => e.lsp.CompletionProvider);
        const hasReferencesProvider = this.hasService(e => e.lsp.ReferencesProvider);
        const hasDocumentSymbolProvider = this.hasService(e => e.lsp.DocumentSymbolProvider);
        const hasDefinitionProvider = this.hasService(e => e.lsp.DefinitionProvider);
        const hasDocumentHighlightProvider = this.hasService(e => e.lsp.DocumentHighlightProvider);
        const hasFoldingRangeProvider = this.hasService(e => e.lsp.FoldingRangeProvider);
        const hasHoverProvider = this.hasService(e => e.lsp.HoverProvider);
        const hasRenameProvider = this.hasService(e => e.lsp.RenameProvider);
        const hasCallHierarchyProvider = this.hasService(e => e.lsp.CallHierarchyProvider);
        const codeLensProvider = this.services.lsp.CodeLensProvider;
        const hasDeclarationProvider = this.hasService(e => e.lsp.DeclarationProvider);
        const result = {
            capabilities: {
                workspace: {
                    workspaceFolders: {
                        supported: true
                    }
                },
                executeCommandProvider: commandNames && {
                    commands: commandNames
                },
                textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
                completionProvider: hasCompletionProvider ? {} : undefined,
                referencesProvider: hasReferencesProvider,
                documentSymbolProvider: hasDocumentSymbolProvider,
                definitionProvider: hasDefinitionProvider,
                typeDefinitionProvider: hasGoToTypeProvider,
                documentHighlightProvider: hasDocumentHighlightProvider,
                codeActionProvider: hasCodeActionProvider,
                documentFormattingProvider: hasFormattingService,
                documentRangeFormattingProvider: hasFormattingService,
                documentOnTypeFormattingProvider: formattingOnTypeOptions,
                foldingRangeProvider: hasFoldingRangeProvider,
                hoverProvider: hasHoverProvider,
                renameProvider: hasRenameProvider ? {
                    prepareProvider: true
                } : undefined,
                semanticTokensProvider: hasSemanticTokensProvider
                    ? semantic_token_provider_1.DefaultSemanticTokenOptions
                    : undefined,
                signatureHelpProvider: signatureHelpOptions,
                implementationProvider: hasGoToImplementationProvider,
                callHierarchyProvider: hasCallHierarchyProvider
                    ? {}
                    : undefined,
                documentLinkProvider: documentLinkProvider
                    ? { resolveProvider: Boolean(documentLinkProvider.resolveDocumentLink) }
                    : undefined,
                codeLensProvider: codeLensProvider
                    ? { resolveProvider: Boolean(codeLensProvider.resolveCodeLens) }
                    : undefined,
                declarationProvider: hasDeclarationProvider
            }
        };
        return result;
    }
    async initialized(params) {
        this.onInitializedEmitter.fire(params);
        this.onInitializedEmitter.dispose();
    }
}
exports.DefaultLanguageServer = DefaultLanguageServer;
function startLanguageServer(services) {
    const connection = services.lsp.Connection;
    if (!connection) {
        throw new Error('Starting a language server requires the languageServer.Connection service to be set.');
    }
    addDocumentsHandler(connection, services);
    addDiagnosticsHandler(connection, services);
    addCompletionHandler(connection, services);
    addFindReferencesHandler(connection, services);
    addDocumentSymbolHandler(connection, services);
    addGotoDefinitionHandler(connection, services);
    addGoToTypeDefinitionHandler(connection, services);
    addGoToImplementationHandler(connection, services);
    addDocumentHighlightsHandler(connection, services);
    addFoldingRangeHandler(connection, services);
    addFormattingHandler(connection, services);
    addCodeActionHandler(connection, services);
    addRenameHandler(connection, services);
    addHoverHandler(connection, services);
    addSemanticTokenHandler(connection, services);
    addExecuteCommandHandler(connection, services);
    addSignatureHelpHandler(connection, services);
    addCallHierarchyHandler(connection, services);
    addCodeLensHandler(connection, services);
    addDocumentLinkHandler(connection, services);
    addConfigurationChangeHandler(connection, services);
    addGoToDeclarationHandler(connection, services);
    connection.onInitialize(params => {
        return services.lsp.LanguageServer.initialize(params);
    });
    connection.onInitialized(params => {
        return services.lsp.LanguageServer.initialized(params);
    });
    // Make the text document manager listen on the connection for open, change and close text document events.
    const documents = services.workspace.TextDocuments;
    documents.listen(connection);
    // Start listening for incoming messages from the client.
    connection.listen();
}
exports.startLanguageServer = startLanguageServer;
function addDocumentsHandler(connection, services) {
    const documentBuilder = services.workspace.DocumentBuilder;
    const mutex = services.workspace.MutexLock;
    function onDidChange(changed, deleted) {
        mutex.lock(token => documentBuilder.update(changed, deleted, token));
    }
    const documents = services.workspace.TextDocuments;
    documents.onDidChangeContent(change => {
        onDidChange([vscode_uri_1.URI.parse(change.document.uri)], []);
    });
    connection.onDidChangeWatchedFiles(params => {
        const changedUris = params.changes.filter(e => e.type !== vscode_languageserver_1.FileChangeType.Deleted).map(e => vscode_uri_1.URI.parse(e.uri));
        const deletedUris = params.changes.filter(e => e.type === vscode_languageserver_1.FileChangeType.Deleted).map(e => vscode_uri_1.URI.parse(e.uri));
        onDidChange(changedUris, deletedUris);
    });
}
exports.addDocumentsHandler = addDocumentsHandler;
function addDiagnosticsHandler(connection, services) {
    const documentBuilder = services.workspace.DocumentBuilder;
    documentBuilder.onBuildPhase(documents_1.DocumentState.Validated, async (documents, cancelToken) => {
        for (const document of documents) {
            if (document.diagnostics) {
                connection.sendDiagnostics({
                    uri: document.uri.toString(),
                    diagnostics: document.diagnostics
                });
            }
            if (cancelToken.isCancellationRequested) {
                return;
            }
        }
    });
}
exports.addDiagnosticsHandler = addDiagnosticsHandler;
function addCompletionHandler(connection, services) {
    connection.onCompletion(createRequestHandler((services, document, params, cancelToken) => {
        var _a;
        return (_a = services.lsp.CompletionProvider) === null || _a === void 0 ? void 0 : _a.getCompletion(document, params, cancelToken);
    }, services));
}
exports.addCompletionHandler = addCompletionHandler;
function addFindReferencesHandler(connection, services) {
    connection.onReferences(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.ReferencesProvider) === null || _a === void 0 ? void 0 : _a.findReferences(document, params, cancelToken); }, services));
}
exports.addFindReferencesHandler = addFindReferencesHandler;
function addCodeActionHandler(connection, services) {
    connection.onCodeAction(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.CodeActionProvider) === null || _a === void 0 ? void 0 : _a.getCodeActions(document, params, cancelToken); }, services));
}
exports.addCodeActionHandler = addCodeActionHandler;
function addDocumentSymbolHandler(connection, services) {
    connection.onDocumentSymbol(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.DocumentSymbolProvider) === null || _a === void 0 ? void 0 : _a.getSymbols(document, params, cancelToken); }, services));
}
exports.addDocumentSymbolHandler = addDocumentSymbolHandler;
function addGotoDefinitionHandler(connection, services) {
    connection.onDefinition(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.DefinitionProvider) === null || _a === void 0 ? void 0 : _a.getDefinition(document, params, cancelToken); }, services));
}
exports.addGotoDefinitionHandler = addGotoDefinitionHandler;
function addGoToTypeDefinitionHandler(connection, services) {
    connection.onTypeDefinition(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.TypeProvider) === null || _a === void 0 ? void 0 : _a.getTypeDefinition(document, params, cancelToken); }, services));
}
exports.addGoToTypeDefinitionHandler = addGoToTypeDefinitionHandler;
function addGoToImplementationHandler(connection, services) {
    connection.onImplementation(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.ImplementationProvider) === null || _a === void 0 ? void 0 : _a.getImplementation(document, params, cancelToken); }, services));
}
exports.addGoToImplementationHandler = addGoToImplementationHandler;
function addGoToDeclarationHandler(connection, services) {
    connection.onDeclaration(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.DeclarationProvider) === null || _a === void 0 ? void 0 : _a.getDeclaration(document, params, cancelToken); }, services));
}
exports.addGoToDeclarationHandler = addGoToDeclarationHandler;
function addDocumentHighlightsHandler(connection, services) {
    connection.onDocumentHighlight(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.DocumentHighlightProvider) === null || _a === void 0 ? void 0 : _a.getDocumentHighlight(document, params, cancelToken); }, services));
}
exports.addDocumentHighlightsHandler = addDocumentHighlightsHandler;
function addHoverHandler(connection, services) {
    connection.onHover(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.HoverProvider) === null || _a === void 0 ? void 0 : _a.getHoverContent(document, params, cancelToken); }, services));
}
exports.addHoverHandler = addHoverHandler;
function addFoldingRangeHandler(connection, services) {
    connection.onFoldingRanges(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.FoldingRangeProvider) === null || _a === void 0 ? void 0 : _a.getFoldingRanges(document, params, cancelToken); }, services));
}
exports.addFoldingRangeHandler = addFoldingRangeHandler;
function addFormattingHandler(connection, services) {
    connection.onDocumentFormatting(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.Formatter) === null || _a === void 0 ? void 0 : _a.formatDocument(document, params, cancelToken); }, services));
    connection.onDocumentRangeFormatting(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.Formatter) === null || _a === void 0 ? void 0 : _a.formatDocumentRange(document, params, cancelToken); }, services));
    connection.onDocumentOnTypeFormatting(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.Formatter) === null || _a === void 0 ? void 0 : _a.formatDocumentOnType(document, params, cancelToken); }, services));
}
exports.addFormattingHandler = addFormattingHandler;
function addRenameHandler(connection, services) {
    connection.onRenameRequest(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.RenameProvider) === null || _a === void 0 ? void 0 : _a.rename(document, params, cancelToken); }, services));
    connection.onPrepareRename(createRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.RenameProvider) === null || _a === void 0 ? void 0 : _a.prepareRename(document, params, cancelToken); }, services));
}
exports.addRenameHandler = addRenameHandler;
function addSemanticTokenHandler(connection, services) {
    const errorMessage = 'No semantic token provider registered';
    connection.languages.semanticTokens.on(createServerRequestHandler((services, document, params, cancelToken) => {
        if (services.lsp.SemanticTokenProvider) {
            return services.lsp.SemanticTokenProvider.semanticHighlight(document, params, cancelToken);
        }
        return new vscode_languageserver_1.ResponseError(0, errorMessage);
    }, services));
    connection.languages.semanticTokens.onDelta(createServerRequestHandler((services, document, params, cancelToken) => {
        if (services.lsp.SemanticTokenProvider) {
            return services.lsp.SemanticTokenProvider.semanticHighlightDelta(document, params, cancelToken);
        }
        return new vscode_languageserver_1.ResponseError(0, errorMessage);
    }, services));
    connection.languages.semanticTokens.onRange(createServerRequestHandler((services, document, params, cancelToken) => {
        if (services.lsp.SemanticTokenProvider) {
            return services.lsp.SemanticTokenProvider.semanticHighlightRange(document, params, cancelToken);
        }
        return new vscode_languageserver_1.ResponseError(0, errorMessage);
    }, services));
}
exports.addSemanticTokenHandler = addSemanticTokenHandler;
function addConfigurationChangeHandler(connection, services) {
    connection.onDidChangeConfiguration(change => {
        if (change.settings) {
            services.workspace.ConfigurationProvider.updateConfiguration(change);
        }
    });
}
exports.addConfigurationChangeHandler = addConfigurationChangeHandler;
function addExecuteCommandHandler(connection, services) {
    const commandHandler = services.lsp.ExecuteCommandHandler;
    if (commandHandler) {
        connection.onExecuteCommand(async (params, token) => {
            var _a;
            try {
                return await commandHandler.executeCommand(params.command, (_a = params.arguments) !== null && _a !== void 0 ? _a : [], token);
            }
            catch (err) {
                return responseError(err);
            }
        });
    }
}
exports.addExecuteCommandHandler = addExecuteCommandHandler;
function addDocumentLinkHandler(connection, services) {
    var _a;
    const documentLinkProvider = services.lsp.DocumentLinkProvider;
    if (documentLinkProvider) {
        connection.onDocumentLinks(createServerRequestHandler((_, document, params, cancelToken) => documentLinkProvider.getDocumentLinks(document, params, cancelToken), services));
        // Make sure the function doesn't become undefined before actually executing it
        const resolveDocumentLink = (_a = documentLinkProvider.resolveDocumentLink) === null || _a === void 0 ? void 0 : _a.bind(documentLinkProvider);
        if (resolveDocumentLink) {
            connection.onDocumentLinkResolve(async (documentLink, token) => {
                try {
                    return await resolveDocumentLink(documentLink, token);
                }
                catch (err) {
                    return responseError(err);
                }
            });
        }
    }
}
exports.addDocumentLinkHandler = addDocumentLinkHandler;
function addSignatureHelpHandler(connection, services) {
    connection.onSignatureHelp(createServerRequestHandler((services, document, params, cancelToken) => { var _a; return (_a = services.lsp.SignatureHelp) === null || _a === void 0 ? void 0 : _a.provideSignatureHelp(document, params, cancelToken); }, services));
}
exports.addSignatureHelpHandler = addSignatureHelpHandler;
function addCodeLensHandler(connection, services) {
    var _a;
    const codeLensProvider = services.lsp.CodeLensProvider;
    if (codeLensProvider) {
        connection.onCodeLens(createServerRequestHandler((_, document, params, cancelToken) => codeLensProvider.provideCodeLens(document, params, cancelToken), services));
        const resolveCodeLens = (_a = codeLensProvider.resolveCodeLens) === null || _a === void 0 ? void 0 : _a.bind(codeLensProvider);
        if (resolveCodeLens) {
            connection.onCodeLensResolve(async (codeLens, token) => {
                try {
                    return await resolveCodeLens(codeLens, token);
                }
                catch (err) {
                    return responseError(err);
                }
            });
        }
    }
}
exports.addCodeLensHandler = addCodeLensHandler;
function addCallHierarchyHandler(connection, services) {
    const errorMessage = 'No call hierarchy provider registered';
    connection.languages.callHierarchy.onPrepare(createServerRequestHandler((services, document, params, cancelToken) => {
        var _a;
        if (services.lsp.CallHierarchyProvider) {
            return (_a = services.lsp.CallHierarchyProvider.prepareCallHierarchy(document, params, cancelToken)) !== null && _a !== void 0 ? _a : null;
        }
        return new vscode_languageserver_1.ResponseError(0, errorMessage);
    }, services));
    connection.languages.callHierarchy.onIncomingCalls(createCallHierarchyRequestHandler((services, params, cancelToken) => {
        var _a;
        if (services.lsp.CallHierarchyProvider) {
            return (_a = services.lsp.CallHierarchyProvider.incomingCalls(params, cancelToken)) !== null && _a !== void 0 ? _a : null;
        }
        return new vscode_languageserver_1.ResponseError(0, errorMessage);
    }, services));
    connection.languages.callHierarchy.onOutgoingCalls(createCallHierarchyRequestHandler((services, params, cancelToken) => {
        var _a;
        if (services.lsp.CallHierarchyProvider) {
            return (_a = services.lsp.CallHierarchyProvider.outgoingCalls(params, cancelToken)) !== null && _a !== void 0 ? _a : null;
        }
        return new vscode_languageserver_1.ResponseError(0, errorMessage);
    }, services));
}
exports.addCallHierarchyHandler = addCallHierarchyHandler;
function createCallHierarchyRequestHandler(serviceCall, sharedServices) {
    const serviceRegistry = sharedServices.ServiceRegistry;
    return async (params, cancelToken) => {
        const uri = vscode_uri_1.URI.parse(params.item.uri);
        const language = serviceRegistry.getServices(uri);
        if (!language) {
            console.error(`Could not find service instance for uri: '${uri.toString()}'`);
            throw new Error();
        }
        try {
            return await serviceCall(language, params, cancelToken);
        }
        catch (err) {
            return responseError(err);
        }
    };
}
exports.createCallHierarchyRequestHandler = createCallHierarchyRequestHandler;
function createServerRequestHandler(serviceCall, sharedServices) {
    const documents = sharedServices.workspace.LangiumDocuments;
    const serviceRegistry = sharedServices.ServiceRegistry;
    return async (params, cancelToken) => {
        const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
        const language = serviceRegistry.getServices(uri);
        if (!language) {
            console.error(`Could not find service instance for uri: '${uri.toString()}'`);
            throw new Error();
        }
        const document = documents.getOrCreateDocument(uri);
        if (!document) {
            throw new Error();
        }
        try {
            return await serviceCall(language, document, params, cancelToken);
        }
        catch (err) {
            return responseError(err);
        }
    };
}
exports.createServerRequestHandler = createServerRequestHandler;
function createRequestHandler(serviceCall, sharedServices) {
    const documents = sharedServices.workspace.LangiumDocuments;
    const serviceRegistry = sharedServices.ServiceRegistry;
    return async (params, cancelToken) => {
        const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
        const language = serviceRegistry.getServices(uri);
        if (!language) {
            console.error(`Could not find service instance for uri: '${uri.toString()}'`);
            return null;
        }
        const document = documents.getOrCreateDocument(uri);
        if (!document) {
            return null;
        }
        try {
            return await serviceCall(language, document, params, cancelToken);
        }
        catch (err) {
            return responseError(err);
        }
    };
}
exports.createRequestHandler = createRequestHandler;
function responseError(err) {
    if ((0, promise_util_1.isOperationCancelled)(err)) {
        return new vscode_languageserver_1.ResponseError(vscode_languageserver_1.LSPErrorCodes.RequestCancelled, 'The request has been cancelled.');
    }
    if (err instanceof vscode_languageserver_1.ResponseError) {
        return err;
    }
    throw err;
}
//# sourceMappingURL=language-server.js.map